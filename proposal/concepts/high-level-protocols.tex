\قسمت{پروتکل‌های لایه کاربرد}

به جز پروتکل‌های لایه پیوند داده و فیزیکی، پروتکل‌های سطح بالای زیادی برای اینترنت اشیا پیشنهاد شده‌اند.
مثلا پروتکل \متن‌لاتین{mDNS} می‌تواند به عملیات \متن‌لاتین{Name Resolution} در اینرتنت اشیا کمک کند یا پروتکل
\متن‌لاتین{DNS-DS} میتواند به وسیله‌ی کلاینت‌ها برای پیدا کردن سرویس‌های موردنظرشان به وابسته‌ی \متن‌لاتین{mDNS} استفاده شود
\مرجع{Lin2017}.

با توجه به نیازمندی‌های برنامه‌ها، می‌توان دو شیوه برای جابجایی اطلاعات در نظر گرفت. روش \متن‌لاتین{Request-Response}
که در آن متقاضی برای سرویس به پاسخ‌دهنده، درخواست می‌دهد.
روش \متن‌لاتین{Publish-Subscribe} که در آن نقاط انتهایی به صورت غیرهمگام اطلاعات را جابجا می‌کنند
\مرجع{Ferrari2018}.

توجه زیادی به استفاده از سرویس‌های وب و \متن‌لاتین{REST} در سیستم‌های اینترنت اشیا وجود دارد چرا که
می‌توانند پیچیدگی برنامه‌ها را کاهش داده و بازاستفاده از نرم‌افزارها را بهبود دهند.
\متن‌لاتین{REST} یک سبک معماری نرم‌افزاری است که محدودیت‌هایی را برای سیستم‌های \متن‌لاتین{hypermedia} توزیع شده مانند وب
تعریف می‌کند تا تصمیمات طراحی را به سوی بهبود معیارهای کیفی سوق دهد.
\متن‌لاتین{REST} سبک معماری جا افتاده در سیستم‌های مبتنی بر وب است.
بیشترین پروتکل ارتباطی مورد استفاده در برنامه‌های مبتنی بر \متن‌لاتین{REST} پروتکل \متن‌لاتین{HTTP} است.
در سبک معماری \متن‌لاتین{REST} هر قسمت یک منبع فرض می‌شود، که می‌توان با استفاده از یک رابط مشترک
دستورات کلی ساخت، دریافت، به‌روزرسانی و حذف کردن (\متن‌لاتین{CRUD}) را اعمال نمود.
با این وجود استفاده از \متن‌لاتین{HTTP} در شبکه‌های محدود با توجه به اندازه‌اش، می‌تواند
باعث قطعه قطعه شدن شود که گذردهی را کاهش می‌دهد
\مرجع{Afzal2022}.

شِمای معمول دیگر برای برنامه‌های مبتنی بر \متن‌لاتین{REST}، استفاده از پروتکل \متن‌لاتین{Constrained Application Protocol} یا \متن‌لاتین{CoAP}
است. \متن‌لاتین{CoAP} یک پروتکل ارتباطی لایه کاربرد است که برای سناریوهای محدود پیشنهاد شده است چرا که در مقایسه با \متن‌لاتین{HTTP}
بسیار سبکتر است.
با وجود اینکه می‌توان اندازه بسته‌ی \متن‌لاتین{CoAP} را در قیاس با \متن‌لاتین{HTTP} تا ۹۰ درصد کوچکتر کرد اما سرآیندهای این پروتکل با توجه
استفاده آن از پروتکل \متن‌لاتین{IP} برای لینک‌های \متن‌لاتین{LPWAN} بزرگ است.
بنابراین تلاش دیگری از کارگروه \متن‌لاتین{LPWAN} \متن‌لاتین{IETF} در راستای کپسوله کردن پروتکل‌های \متن‌لاتین{UDP/IP/CoAP}
به واسطه‌ی شِمای \متن‌لاتین{SCHC} است که اجازه فشرده‌سازی و قطعه قطعه کردن، می‌دهد.
افزون بر این، \متن‌لاتین{Concise Binary Object Representation} یا \متن‌لاتین{CBOR} یک فرمت داده‌ای پیشنهاد شده برای سناریوهای
شبکه‌های محدود است که برای اندازه کد کم و اندازه بسته کوچک طراحی شده است.
\متن‌لاتین{CBOR} مدل داده‌ای \متن‌لاتین{JSON} با اجازه استفاده از داده‌های باینری، تغییر می‌دهد.
استفاده از چنین شِماهایی می‌تواند نیاز به قطعه قطعه کردن را کم کرده یا از بین ببرد
\مرجع{Afzal2022}.

کارگروه \متن‌لاتین{LPWAN} \متن‌لاتین{IETF} شِما \متن‌لاتین{Static Context Header Compression} یا اختصارا \متن‌لاتین{SCHC}
برای قطعه قطعه کردن و فشرده‌سازی بسته‌های \متن‌لاتین{CoAP/UDP/IPv6} به جهت آماده کردن آن‌ها برای انتقال بر بستر \متن‌لاتین{LPWAN}
پیشنهاد داده است. به طور مشخص کمترین واحد انتقال در پروتکل \متن‌لاتین{IPv6} برابر با ۱۲۸۰ بایت است و به این ترتیب یک بسته \متن‌لاتین{IPv6}
نیاز به قطعات بسیاری تنها برای ارسال سرآیند \متن‌لاتین{IPv6} دارد. برای حل این مشکلات \متن‌لاتین{SCHC} به عنوان \متن‌سیاه{لایه سازگاری}
برای فشرده‌سازی سرآیند و قطعه قطعه کردن بسته‌ها در صورت نیاز توسعه پیدا کرده است.
ذکر این نکته خالی از لطف نیست که فشرده‌سازی و استخراج داده‌ها نیاز به توان پردازشی شده و تاخیر در ارتباط را افزایش می‌دهد
\مرجع{Afzal2022}.

\زیرقسمت{\متن‌لاتین{CoAP}}

\متن‌لاتین{Constraint Application Protocol} یا اختصارا \متن‌لاتین{CoAP}
یک پروتکل ارتباطی وب خاص منظوره است که عموما برای ساده‌سازی پشته پروتکلی بر پایه \متن‌لاتین{UDP/IP} پیاده‌سازی شده
و باعث می‌شود بتوان از آن بر بستر شبکه‌های محدود مانند \متن‌لاتین{LPWAN}ها استفاده کرد.
این پروتکل \متن‌لاتین{REST} سرویس‌های پایه‌ای مشابه‌ای با \متن‌لاتین{HTTP} مانند شِما، متدها، حافظه نهان و فضای‌آدرس فراهم می‌آورد.
\متن‌لاتین{CoAP} به \متن‌لاتین{HTTP} شبیه بوده اما از آن پیچیدگی کمتری دارد.
علاوه بر این \متن‌لاتین{CoAP} اجازه تعامل بر پایه‌ی تراکنش‌های ساده تقاضا و پاسخ را می‌دهد.
این پروتکل از متدهای مشابه \متن‌لاتین{HTTP} همچون \متن‌لاتین{GET}، \متن‌لاتین{POST}، \متن‌لاتین{PUT} و \متن‌لاتین{DELETE} استفاده می‌کند.
همچنین \متن‌لاتین{CoAP} بر زیرساخت \متن‌لاتین{IPv6} و هچنین بیشتر شبکه‌های \متن‌لاتین{IPv4} فعالیت می‌کند
\مرجع{Afzal2022}.

\زیرقسمت{\متن‌لاتین{MQTT}}

پروتکل \متن‌لاتین{Messaging Queue Telemetry Transport} که مختصرا \متن‌لاتین{MQTT} نامیده می‌شود یکی از پروتکل‌ها پر استفاده در اینترنت اشیا است.
این پروتکل یک پروتکل با معماری انتشار و اشتراک است که توان مصرفی پایینی دارد.
\متن‌لاتین{MQTT} یک پروتکل لایه کاربرد است که برای لایه انتقال از \متن‌لاتین{TCP/IP} و پورت‌های ۱۸۸۳ و ۸۸۸۳ (به ترتیب برای ارتباط رمز شده و ارتباط رمز نشده) استفاده می‌کند. البته پژوهش‌هایی چون \مرجع{Fernndez2021} سعی در تغییر لایه انتقال به \متن‌لاتین{UDP/Quic} داشته‌اند
\مرجع{Mishra2021}.

سه نقش در معماری \متن‌لاتین{MQTT} تعریف شده است. نقش اول کلاینت تولید کننده داده است که به آن \متن‌لاتین{Producer} گفته می‌شود. نقش دوم سرور دلال پیام است و نقش سوم کلاینت دریافت کننده داده است که به آن \متن‌لاتین{Subscriber} گفته می‌شود.
از \متن‌لاتین{Topic} برای مشخص کردن جریان‌های داده‌ای استفاده می‌شود و در تولید کننده داده می‌بایست برای داده‌ی خود \متن‌لاتین{Topic} داشته باشد و هر دریافت کننده داده روی \متن‌لاتین{Topic} خاصی مشترک می‌شود.
این \متن‌لاتین{Topic}ها می‌توانند به صورت سلسله مراتبی نیز می‌تواند تشکیل شود
\مرجع{Mishra2021}.

در پروتکل \متن‌لاتین{‌MQTT} سه سطح مختلف از کیفیت سرویس تعریف می‌شود. در کیفیت سرویس \متن‌لاتین{QoS0} پیام‌ها به صورت ارسال و فراموش کردن ارسال می‌شوند و هیچ تضمینی برای موفیت این ارسال وجود ندارد.
در کیفیت سرویس \متن‌لاتین{QoS1} پیام‌ها حداقل یکبار تحویل داده خواهند شد، در این حالت کلاینت ارسال‌کننده پس از ارسال منتظر پیام \متن‌لاتین{PUBACK} می‌ماند و در صورت عدم دریافت آن فرآیند ارسال را دوباره تکرار می‌کند.
در کیفیت سرویس \متن‌لاتین{QoS2} پیام‌ها دقیقا یکبار تحویل داده می‌شوند، این بالاترین کیفیت سرویس بوده و منابع زیادی را مصرف می‌کند
\مرجع{Mishra2021}.

در نظر داشته باشید که کیفیت سرویس پروتکل \متن‌لاتین{MQTT} به صورت انتها به انتها نیست و به ارتباط میان دلال پیام و کلاینت‌ها وابسته است.
کیفیت سرویس پیام دریافت شده از سوی \متن‌لاتین{Subscriber} وابسته کیفیت سرویس عملیات انتشار و اشتراک است. اگر کلاینت الف عملیات انتشار را با کیفیت سرویس بالاتری
نسبت به عملیات اشتراک در کلاینت ب انجام دهد کیفیت سرویسی که سرور پیام را به دست کلاینت ب می‌رساند کیفیت سرویسی است که کلاینت ب در عملیات اشتراک استفاده کرده است.
اگر کلاینت الف عملیات انتشار را با کیفیت سرویس پایین‌تری نسبت به عملیات اشتراک در کلاینت ب انجام دهد کیفیت سرویسی که سرور پیام را به دست کلاینت ب می‌رساند کیفیت سرویسی است که
کلاینت الف در عملیات انتشار استفاده کرده است
\مرجع{MQTTQoS}.

همانطور که اشاره شد پروتکل \متن‌لاتین{MQTT} در کاربردهای اینترنت اشیا می‌تواند برای ارتباط مستقیم میان اشیا و اپلیکیشن مورد استفاده قرار بگیرد. از سوی دیگر این پروتکل با توجه به ماهیت غیرهمزمانی که دارد یکی از راه‌های شناخته شده برای ارتباط میان سرور شبکه \متن‌لاتین{LoRaWAN}
و برنامه‌های کاربردی و دروازه است. این امر در معماری سامانه \متن‌لاتین{Chirpstack} (شکل \رجوع{شکل:معماری سامانه Chripstack}) که یکی از بسترهای شناخته شده و متن باز برای \متن‌لاتین{LoRa} است، مشهود است.

\شروع{شکل}
\درج‌تصویر[width=\textwidth]{./img/chirpstack-architecture.png}
\تنظیم‌ازوسط
\شرح{معماری \متن‌لاتین{LoRaWAN} سرور متن باز \متن‌لاتین{Chirpstack}}
\برچسب{شکل:معماری سامانه Chripstack}
\پایان{شکل}

\زیرقسمت{\متن‌لاتین{QUIC}}

امروز با گسترش سرویس‌های حساس به تاخیر در دنیای وب و استفاده از بستر وب برای برنامه‌های کاربردی باعث فشار برای کاهش تاخیر وب شده است. تاخیر وب تاثر مستقیمی بر تجربه کاربران دارد
و دم تاخیر باعث می‌شود که گسترش بستر وب با مشکل مواجه شود.
از سوی دیگر وب امروز از سمت ترافیک غیر امن به ترافیک امن حرکت کرده است و این خود باعث افزایش تاخیر شده است.
کاهش تاخیر عموما در لایه انتقال با محدودیت‌های \متن‌لاتین{TCP/TLS} مواجه شده‌اند. در ادامه به مرور این محدودیت‌ها می‌پردازیم
\مرجع{10.1145/3098822.3098842}.

\متن‌سیاه{بهبود پروتکل}: با وجود ارائه پروتکل‌های انتقال جدید برای برآورده کردن نیازهای برنامه‌های کاربردی در ورای سرویس ساده \متن‌لاتین{TCP}، این پروتکل‌ها به صورت گسترده پیاده‌سازی نشده‌اند.
چرا که جعبه‌های میانی، نقطه کنترل در معماری اینترنت هستند، دیوارهای آتش ترافیک‌های غیرمعمول را به دلایل امنیتی بلوکه می‌کنند و ترجمه‌کنندگان آدرس شبکه (\متن‌لاتین{NAT})
سرآیند انتقال بسته‌ها را بازنویسی می‌کنند بنابراین نیاز است که به صورت مشخص از پروتکل انتقال جدید پشتیبانی کنند.
هر بسته‌ای که بدون امنیت انتها به انتها در بستر اینترنت در حرکت است مانند سرآیند بسته‌های \متن‌لاتین{TCP} ممکن است توسط جعبه‌های میانی مورد تغییر یا بررسی قرار بگیرد.
گسترش \متن‌لاتین{TCP} به حدی است که کوچکترین تغییرات پروتکل نیاز به سال‌ها زمان در جهت پیاده‌سازی گسترده دارد
\مرجع{10.1145/3098822.3098842}.

\متن‌سیاه{بهبود پیاده‌سازی}: پروتکل \متن‌لاتین{TCP} عموما در سطح سیستم عامل پیاده‌سازی شده است. با گسترش اینترنت و تهدیدهای امنیتی نیاز است که تغییرات کلاینت‌ها به سرعت اتفاق بیافتد.
این درهم تنیدگی پیاده‌سازی پروتکل \متن‌لاتین{TCP} و سیستم عامل باعث می‌شود که به روزرسانی این پیاده‌سازی منجر به یک به روزرسانی در سطح سیستم شود که عموما به روزرسانی‌ها در این سطح
با احتیاط انجام می‌گیرند. البته با پیشرفت‌های این سال‌ها پروسه به روزرسانی سیستم عامل بسیار سریعتر شده است اما هنوز ماه‌ها زمان برای یک نسخه قابل اتکا از سیستم عامل لازم است و این باعث
محدود شدن سرعت برای حتی ساده‌ترین تغییرات شبکه‌ای می‌شود
\مرجع{10.1145/3098822.3098842}.

\متن‌سیاه{تاخیر دست‌داد}: عمومیت پروتکل‌های \متن‌لاتین{TCP} و \متن‌لاتین{TLS} در حال خدمت به گسترش اینترنت است اما سربار لایه‌بندی با نیازمندی تاخیر در پشته \متن‌لاتین{HTTPS}،
بسیار مشهود شده است. یک ارتباط \متن‌لاتین{TCP} پیش از آنکه هیچ داده‌ی کاربردی بتواند ارسال شود نیاز به یک تاخیر رفت و برگشت برای ساخت ارتباط دارد و \متن‌لاتین{TLS} دو رفت و برگشت
به این تاخیر اضافه می‌کند. اهمیت این مساله زمانی مشخص می‌شود که دقت کنیم در این سال‌های پهنای باند گسترش پیدا کرده است اما سرعت نور ثابت مانده است. از سوی دیگر بیشتر تراکنش‌های دنیای وب
کوتاه بوده و بسیار تحت تاثیر این دست‌دادهای غیرضروری هستند
\مرجع{10.1145/3098822.3098842}.

\متن‌سیاه{تاخیر بلاک شدن ابتدای خط}: در نسخه \متن‌لاتین{HTTP/1.1} پیشنهاد می‌شد برای کاهش تاخیر از چند ارتباط همزمان استفاده شود و سرورها نیز تعداد ارتباط‌های همزمان را محدود کنند.
در نسخه \متن‌لاتین{HTTP/2} از مالتی پلکس کردن روی یک ارتباط استفاده می‌شد و بنابراین پیشنهاد می‌شد با هر سرور از یک ارتباط استفاده شود.
اما انتزاع \متن‌لاتین{TCP} از جریان بایت‌ها باعث می‌شود تا برنامه نتواند کنترلی برای فرآیند فریم‌بندی ارتباط داشته باشد و فریم‌های اطلاعاتی می‌بایست برای باز ارسال فریم‌های قبلتر منتظر بمانند
\مرجع{10.1145/3098822.3098842}.

پروتکل \متن‌لاتین{QUIC} توسط گوگل در سال ۲۰۱۳ پیشنهاد شد و ۳ سال بعد کاگروهی در \متن‌لاتین{IETF} برای استانداردسازی آن شکل گرفت. این پروتکل در لایه کاربر بوده و بر پایه \متن‌لاتین{UDP} کار می‌کند.
هدف این پروتکل جایگزین کردن پشته سابق \متن‌لاتین{HTTP2}، \متن‌لاتین{TLS} و \متن‌لاتین{TCP} است.
پیاده‌سازی این پروتکل در لایه کاربر فرآیند توسعه و سازگاری آن را ساده می‌کند و از سوی دیگر استفاده از \متن‌لاتین{UDP} اجازه می‌دهد به سادگی بر بستر شبکه‌های حاضر فعالیت کند.
این پروتکل از اپراتورهای شبکه و سازندگان تجهیزات مستقل بوده و اجازه می‌دهد برنامه‌های کاربردی بتوانند به صورت مستقیم از منافع آن بهره ببرند
\مرجع{10.1145/3098822.3098842}.

ویژگی‌های پروتکل \متن‌لاتین{QUIC} را می‌توان به شرح زیر برشمارد:
\مرجع{10.1145/3098822.3098842}
\شروع{فقرات}
\فقره این پروتکل با ترکیب دست‌داد لایه‌های انتقال و رمزنگاری زمان رفت و برگشت‌های لازم برای شکل‌گیری ارتباط را کمینه می‌کند.
\فقره این پروتکل با مالتی‌پلکس کردن چند درخواست‌ها و پاسخ‌هایشان روی یک ارتباط به وسیله فراهم آوردن یک جریان برای هر کدام باعث می‌شود تا هیچ پاسخی توسط دیگری بلاک نشود.
\فقره این پروتکل باعث می‌شود تا ارتباط‌ها با تغییر آدرس \متن‌لاتین{IP} ادامه پیدا کنند. برای این کار \متن‌لاتین{QUIC} از شناسه ارتباط به جای پنج‌تایی \متن‌لاتین{IP/Port/Protocol} استفاده می‌کند.
\فقره این پروتکل بازیابی بسته‌ها را به وسیله استفاده از شناسه یکتا برای بسته‌ها، جلوگیری از ابهام در باز ارسال و سیگنال \متن‌لاتین{ACK} صریح برای محاسبه دقیق زمان رفت و برگشت بهبود می‌بخشد. اگر بخواهیم بهتر بیان کنیم برخلاف \متن‌لاتین{TCP} در این پروتکل
بسته‌های باز ارسال شده شناسه متفاوتی از بسته‌ی اصلی دارند و همین امر محاسبه زمان رفت و برگشت برای \متن‌لاتین{ACK} آن‌ها را ساده‌تر می‌کند. در نظر داشته باشید که ترتیب بسته‌ها با توجه به شناسه‌ی آن‌ها در جریانشان مشخص می‌شود.
\فقره این پروتکل بسته‌ها را رمزنگاری و اهراز هویت می‌کند و از این رو جلو خوانده یا تغییر آن‌ها توسط جعبه‌های میانی گرفته می‌شود.
\فقره این پروتکل کنترل جریان فراهم می‌آورد و مطمئن می‌شود که همه بافر در گیرنده توسط یک جریان مصرف نشود و از سوی دیگر میزان داده‌ی بافر شده در گیرنده آهسته را محدود می‌کند. در واقع این پروتکل در سطح ارتباط و در سطح جریان کنترل صورت می‌دهد.
\فقره این پروتکل دارای یک رابط ماژولار برای کنترل ازدحام است.
\پایان{فقرات}
